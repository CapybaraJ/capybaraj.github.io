<!-- build time:Mon Apr 20 2020 11:02:25 GMT+0800 (中国标准时间) --><!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><title>智能合约漏洞介绍2 | CapybaraJ&#39;s Blog~</title><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="description" content="这篇讲述DASP TOP 10后面3类：未严格判断不安全函数调用返回值、拒绝服务、伪随机性、提前交易、时间操纵、其他未知短地址攻击"><meta name="keywords" content="SmartContract"><meta property="og:type" content="article"><meta property="og:title" content="智能合约漏洞介绍2"><meta property="og:url" content="https://fatheadrat.tk/2020/04/03/smartcontract-vulns-2/index.html"><meta property="og:site_name" content="CapybaraJ&#39;s Blog~"><meta property="og:description" content="这篇讲述DASP TOP 10后面3类：未严格判断不安全函数调用返回值、拒绝服务、伪随机性、提前交易、时间操纵、其他未知短地址攻击"><meta property="og:locale" content="default"><meta property="og:image" content="https://i.loli.net/2020/04/20/vKRM7dZBpP2lDuO.png"><meta property="og:updated_time" content="2020-04-20T03:02:09.904Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="智能合约漏洞介绍2"><meta name="twitter:description" content="这篇讲述DASP TOP 10后面3类：未严格判断不安全函数调用返回值、拒绝服务、伪随机性、提前交易、时间操纵、其他未知短地址攻击"><meta name="twitter:image" content="https://i.loli.net/2020/04/20/vKRM7dZBpP2lDuO.png"><link rel="alternative" href="/atom.xml" title="CapybaraJ&#39;s Blog~" type="application/atom+xml"><link rel="icon" href="/img/favicon.ico"><link rel="stylesheet" href="/css/style.css"><link herf="//fonts.googleapis.com/css?family=Source+Code+Pro&display=swap" rel="stylesheet" type="text/css"><!--[if lt IE 9]><script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7/html5shiv.min.js"></script><![endif]--><script type="text/javascript">var isWX=/micromessenger/i.test(navigator.userAgent);isWX&&(document.write('<br/><br/><h1 style="text-align: center;font-size:32px;" >╮(╯_╰)╭</h1><br/><br/><h4 style="text-align: center;" >请在浏览器中打开。</h4><br/><h4 style="text-align: center;" >Please open in the browser.</h4>'),window.stop?window.stop():document.execCommand("Stop"))</script></head></html><body><div id="container"><div id="wrap"><header id="header"><div id="banner"></div><div id="header-outer" class="outer"><nav id="upper-nav" class="inner"><a id="main-nav-toggle" class="nav-icon"></a><div class="sub-nav"><a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a> <a id="nav-github" class="nav-icon" href="https://github.com/capybaraj"></a></div></nav><div id="header-title"><h1 id="blog-title-wrap"><a href="/" id="blog-title">CapybaraJ&#39;s Blog~</a></h1></div><div id="contenedor"><ul class="cube"><li class="cara"><img src="/img/cube/health.png" style="height:50%;width:50%;opacity:.8"></li><li class="cara"><img src="/img/cube/money.png" style="height:50%;width:50%;opacity:.8"></li><li class="cara"><img src="/img/cube/time.png" style="height:50%;width:50%;opacity:.8"></li><li class="cara"><img src="/img/cube/know.png" style="height:50%;width:50%;opacity:.8"></li><li class="cara"><img src="/img/cube/love.png" style="height:50%;width:50%;opacity:.8"></li><li class="cara"><img src="/img/cube/kind.png" style="height:50%;width:50%;opacity:.8"></li></ul></div><nav id="main-nav"><a class="main-nav-link" href="/">Home</a> <a class="main-nav-link" href="/archives">Archives</a> <a class="main-nav-link" href="/about">About</a> <a class="main-nav-link st-search-show-outputs">Search</a></nav></div></header><div class="outer"><section id="main"><article id="post-smartcontract-vulns-2" class="article article-type-post" itemscope itemprop="blogPost"><div class="article-meta"><h3 href="/2020/04/03/smartcontract-vulns-2/" class="article-date"><time datetime="2020-04-03T08:43:33.000Z" itemprop="datePublished">2020-04-03</time></h3><div class="article-category"><a class="article-category-link" href="/categories/BlockChain/">BlockChain</a></div></div><div class="article-inner"><div class="curve-down"><div class="fill-content"><header class="article-header"><h1 class="article-title" itemprop="name">智能合约漏洞介绍2</h1></header><div class="article-entry" itemprop="articleBody"><div id="toc" class="toc-article"><strong class="toc-title">Contents</strong><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#未严格判断不安全函数调用返回值"><span class="toc-text">未严格判断不安全函数调用返回值</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#基本原理"><span class="toc-text">基本原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#实际例子"><span class="toc-text">实际例子</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#拒绝服务"><span class="toc-text">拒绝服务</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#基本原理-1"><span class="toc-text">基本原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#预防技术"><span class="toc-text">预防技术</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#实际例子-1"><span class="toc-text">实际例子</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#GovernMental"><span class="toc-text">GovernMental</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#伪随机性"><span class="toc-text">伪随机性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#使用块变量作为熵源的PRNG"><span class="toc-text">使用块变量作为熵源的PRNG</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#基于过去某个区块的哈希的PRNG"><span class="toc-text">基于过去某个区块的哈希的PRNG</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#预防技术-1"><span class="toc-text">预防技术</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#基于过去区块的区块哈希结合被视为私有的种子的PRNG"><span class="toc-text">基于过去区块的区块哈希结合被视为私有的种子的PRNG</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PRNG易于抢先"><span class="toc-text">PRNG易于抢先</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#实际例子-2"><span class="toc-text">实际例子</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#更好的随机数生成办法"><span class="toc-text">更好的随机数生成办法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Oracle"><span class="toc-text">Oracle</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#BTCReply"><span class="toc-text">BTCReply</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Signidice"><span class="toc-text">Signidice</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#commit-reveal"><span class="toc-text">commit-reveal</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#总结"><span class="toc-text">总结</span></a></li></ol></li></ol></div><p>这篇讲述DASP TOP 10后面3类：未严格判断不安全函数调用返回值、拒绝服务、伪随机性、提前交易、时间操纵、其他未知短地址攻击</p><a id="more"></a><p><a href="https://www.dasp.co/" target="_blank" rel="noopener">DASP Top 10</a>，有个博主把这10类漏洞都大概描述了一下，写得真的是非常好，</p><p>repo大法！<a href="http://rickgray.me/2018/05/17/ethereum-smart-contracts-vulnerabilites-review/" target="_blank" rel="noopener">以太坊智能合约安全入门了解一下（上）</a> <a href="https://rickgray.me/2018/05/26/ethereum-smart-contracts-vulnerabilities-review-part2/" target="_blank" rel="noopener">以太坊智能合约安全入门了解一下（下）</a></p><p>但是这篇文章还是偏向于代码向和实际用例，看心情翻牌讲</p><ol><li>Reentrancy - 重入</li><li>Access Control - 访问控制</li><li>Arithmetic Issues - 算术问题（整数溢出）</li><li><strong>Unchecked Return Values For Low Level Calls - 未严格判断不安全函数调用返回值</strong></li><li><strong>Denial of Service - 拒绝服务</strong></li><li><strong>Bad Randomness - 伪随机性</strong></li><li>Front Running - 提前交易</li><li>Time manipulation - 时间操纵</li><li>Short Address Attack - 短地址攻击</li><li>Unknown Unknowns - 其他未知</li></ol><h2 id="未严格判断不安全函数调用返回值"><a href="#未严格判断不安全函数调用返回值" class="headerlink" title="未严格判断不安全函数调用返回值"></a>未严格判断不安全函数调用返回值</h2><p>这个还是很好理解的，感觉没啥特别好说的，后续在对Mythril的功能测评的时候，会提到这个漏洞的！不过现在如果你去用remix啊这类编译器，还是会提示你这个问题的，所以目前来说，它对以太坊的影响应该会慢慢消失，除非你，从不看warnings…</p><h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><p>引用DASP TOP 10的说法：</p><blockquote><p>One of the deeper features of Solidity are the low level functions <code>call()</code>, <code>callcode()</code>, <code>delegatecall()</code> and <code>send()</code>. Their behavior in accounting for errors is quite different from other Solidity functions, as they will not propagate (or bubble up) and will not lead to a total reversion of the current execution. Instead, they will return a boolean value set to <code>false</code>, and the code will continue to run. This can surprise developers and, if the return value of such low-level calls are not checked, can lead to fail-opens and other unwanted outcomes. Remember, <strong>send can fail!</strong></p><p>低级别的功能<code>call()</code>，<code>callcode()</code>，<code>delegatecall()</code>和<code>send()</code>，它们解决错误的行为与其他Solidity函数完全不同，因为它们不会传播（或冒泡），也不会导致当前执行的全部还原。相反，它们将返回设置为的布尔值<code>false</code>，并且代码将继续运行。这可能会使开发人员感到吃惊，并且，如果不检查此类低级调用的返回值，可能会导致失败打开和其他不良后果。记住，<strong>发送可能失败！</strong></p></blockquote><h3 id="实际例子"><a href="#实际例子" class="headerlink" title="实际例子"></a>实际例子</h3><ul><li><a href="https://www.kingoftheether.com/postmortem.html" target="_blank" rel="noopener">King of the Ether</a><br>(<a href="https://github.com/kieranelby/KingOfTheEtherThrone/blob/v0.4.0/contracts/KingOfTheEtherThrone.sol" target="_blank" rel="noopener">https://github.com/kieranelby/KingOfTheEtherThrone/blob/v0.4.0/contracts/KingOfTheEtherThrone.sol</a>)</li><li><a href="https://aakilfernandes.github.io/blockhashes-are-only-good-for-256-blocks" target="_blank" rel="noopener">Etherpot</a></li></ul><p>不详细说了</p><h2 id="拒绝服务"><a href="#拒绝服务" class="headerlink" title="拒绝服务"></a>拒绝服务</h2><h3 id="基本原理-1"><a href="#基本原理-1" class="headerlink" title="基本原理"></a>基本原理</h3><p>拒绝服务还是有点说头的，不过这篇文章已经说的非常清楚了，我在网上看了很多资料，感觉目前以太坊上拒绝服务也就是以下三种：</p><p>(转自: <a href="https://ethfans.org/posts/comprehensive-list-of-common-attacks-and-defense-part-6#1.%20%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%EF%BC%88DOS%EF%BC%89" target="_blank" rel="noopener">https://ethfans.org/posts/comprehensive-list-of-common-attacks-and-defense-part-6#1.%20%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%EF%BC%88DOS%EF%BC%89</a>)</p><p><strong>1.通过外部操纵映射或数组（Array）循环</strong> ——在我的经历中，我看过此种模式的各种形式。通常情况下，它出现在 <code>owner</code> 希望在其投资者之间分配代币的情况下，以及，在合约中可以看到类似于 <code>distribute()</code> 函数的情况下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">contract DistributeTokens &#123;</span><br><span class="line">    address public owner; <span class="comment">// gets set somewhere</span></span><br><span class="line">    address[] investors; <span class="comment">// array of investors</span></span><br><span class="line">    uint[] investorTokens; <span class="comment">// the amount of tokens each investor gets</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... extra functionality, including transfertoken()</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">invest</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">payable</span> </span>&#123;</span><br><span class="line">        investors.push(msg.sender);</span><br><span class="line">        investorTokens.push(msg.value * <span class="number">5</span>); <span class="comment">// 5 times the wei sent</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">distribute</span>(<span class="params"></span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        <span class="built_in">require</span>(msg.sender == owner); <span class="comment">// only owner</span></span><br><span class="line">        <span class="keyword">for</span>(uint i = <span class="number">0</span>; i &lt; investors.length; i++) &#123; </span><br><span class="line">            <span class="comment">// here transferToken(to,amount) transfers "amount" of tokens to the address "to"</span></span><br><span class="line">            transferToken(investors[i],investorTokens[i]); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意，此合约中的循环遍历的数组可以被人为扩充。攻击者可以创建许多用户帐户，让 <code>investor</code> 数据变得更大。原则上来说，可以让执行 for 循环所需的 Gas 超过区块 Gas 上限，这会使 <code>distribute()</code> 函数变得无法操作。</p><p><strong>2.所有者操作</strong>——另一种常见模式是所有者在合约中具有特定权限，并且必须执行一些任务才能使合约进入下一个状态。例如，ICO 合约要求所有者 <code>finalize()</code> 签订合约，然后才可以转让代币，即</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">bool public isFinalized = <span class="literal">false</span>;</span><br><span class="line">address public owner; <span class="comment">// gets set somewhere</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">finalize</span>(<span class="params"></span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">    <span class="built_in">require</span>(msg.sender == owner);</span><br><span class="line">    isFinalized == <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ... extra ICO functionality</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// overloaded transfer function</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">transfer</span>(<span class="params">address _to, uint _value</span>) <span class="title">returns</span> (<span class="params">bool</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">require</span>(isFinalized);</span><br><span class="line">    <span class="keyword">super</span>.transfer(_to,_value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这种情况下，如果权限用户丢失其私钥或变为非活动状态，则整个代币合约就变得无法操作。在这种情况下，如果 <code>owner</code> 无法调用 <code>finalize()</code> 则代币不可转让；即代币系统的全部运作都取决于一个地址。</p><p><strong>3.基于外部调用的进展状态</strong>——有时候，合约被编写成为了进入新的状态需要将 Ether 发送到某个地址，或者等待来自外部来源的某些输入。这些模式也可能导致 DOS 攻击：当外部调用失败时，或由于外部原因而被阻止时。在发送 Ether 的例子中，用户可以创建一个不接受 Ether 的合约。如果合约需要将 Ether 发送到这个地址才能进入新的状态，那么合约将永远不会达到新的状态，因为 Ether 永远不会被发送到合约。</p><h3 id="预防技术"><a href="#预防技术" class="headerlink" title="预防技术"></a>预防技术</h3><p>在第一个例子中，合约不应该遍历可以被外部用户人为操纵的数据结构。建议使用 withdrawal 模式，每个投资者都会调用取出函数独立取出代币。</p><p>在第二个例子中，改变合约的状态需要权限用户参与。在这样的例子中（只要有可能），如果 <code>owner</code> 已经瘫痪，可以使用自动防故障模式。一种解决方案是将 <code>owner</code> 设为一个多签名合约。另一种解决方案是使用一个时间锁，其中 [13]行 上的需求可以包括在基于时间的机制中，例如 <code>require(msg.sender == owner || now &gt; unlockTime)</code> ，那么在由 <code>unlockTime</code> 指定的一段时间后，任何用户都可以调用函数，完成合约。这种缓解技术也可以在第三个例子中使用。如果需要进行外部调用才能进入新状态，请考虑其可能的失败情况；并添加基于时间的状态进度，防止所需外部调用迟迟不到来。</p><p><em>注意：当然，这些建议都有中心化的替代方案，比如，可以添加 <code>maintenanceUser</code> ，它可以在有需要时出来解决基于 DOS 攻击向量的问题。通常，这类合约包含对这类权力实体的信任问题；不过这不是本节要探讨的内容</em>。</p><h3 id="实际例子-1"><a href="#实际例子-1" class="headerlink" title="实际例子"></a>实际例子</h3><h4 id="GovernMental"><a href="#GovernMental" class="headerlink" title="GovernMental"></a>GovernMental</h4><p><a href="http://governmental.github.io/GovernMental/" target="_blank" rel="noopener">GovernMental</a>是一个很久以前的庞氏骗局，积累了相当多的 Ether。实际上，它曾经积累起 1100 个以太。不幸的是，它很容易受到本节提到的 DOS 漏洞的影响。<a href="https://www.reddit.com/r/ethereum/comments/4ghzhv/governmentals_1100_eth_jackpot_payout_is_stuck/" target="_blank" rel="noopener">这篇 Reddit 帖子</a>描述了合约需要删除一个大的映射来取出以太。删除映射的 Gas 消耗量超过了当时的区块 Gas 上限，因此不可能撤回那 1100 个 Ether。合约地址为 <a href="https://etherscan.io/address/0xf45717552f12ef7cb65e95476f217ea008167ae3" target="_blank" rel="noopener"><code>0xF45717552f12Ef7cb65e95476F217Ea008167Ae3</code></a>，您可以从交易<a href="https://etherscan.io/tx/0x0d80d67202bd9cb6773df8dd2020e7190a1b0793e8ec4fc105257e8128f0506b" target="_blank" rel="noopener"><code>0x0d80d67202bd9cb6773df8dd2020e7190a1b0793e8ec4fc105257e8128f0506b</code></a>中看到，最后有人通过使用 250 万 Gas的交易取出了 1100 Ether 。</p><h2 id="伪随机性"><a href="#伪随机性" class="headerlink" title="伪随机性"></a>伪随机性</h2><p>我觉得伪随机性很好理解，本来区块链就不存在随机熵</p><p>这篇文章我觉得写的非常好，基本上涵盖了当前伪随机数产生的所有问题：<a href="https://blog.positive.com/predicting-random-numbers-in-ethereum-smart-contracts-e5358c6b8620" target="_blank" rel="noopener"><strong>Predicting Random Numbers in Ethereum Smart Contracts</strong></a></p><p>这篇文章的研究思路如下：</p><ol><li>从etherscan.io和GitHub收集了3,649个智能合约。</li><li>然后将这些合同导入到Elasticsearch开源搜索引擎中。</li><li>使用Kibana Web UI进行丰富的搜索和过滤，发现了72种独特的PRNG实现。</li><li>根据对每份合同的人工评估，确定了43份易受伤害的合同。</li></ol><p>然后分为以下四类脆弱的随机数发生器（PRNG）：</p><ul><li>使用块变量作为熵源的PRNG</li><li>基于过去某个区块的哈希的PRNG</li><li>基于过去区块的区块哈希结合被视为私有的种子的PRNG</li><li>PRNG易于抢先</li></ul><p><strong>摘要部分该文章核心如下</strong></p><h3 id="使用块变量作为熵源的PRNG"><a href="#使用块变量作为熵源的PRNG" class="headerlink" title="使用块变量作为熵源的PRNG"></a>使用块变量作为熵源的PRNG</h3><p>这个主要是block.timestamp、block.coinbase、block.difficulty、block.gaslimit、block.number等等块变量引入的，这些变量可以被矿工操纵，所以就很不安全啊；而且这些都公开可查，同一个块内大家都能获取到这些信息，很危险的</p><h3 id="基于过去某个区块的哈希的PRNG"><a href="#基于过去某个区块的哈希的PRNG" class="headerlink" title="基于过去某个区块的哈希的PRNG"></a>基于过去某个区块的哈希的PRNG</h3><p>block.blockhash()可以用来获取区块hash值，但是它有取值范围，只能适用于已经出块的且取值范围是最新的256个块。也就是说，如果超出范围，取值均为0。因此，block.blockhash(block.number) == 0, 因为block.number此时没有出块</p><h4 id="预防技术-1"><a href="#预防技术-1" class="headerlink" title="预防技术"></a>预防技术</h4><blockquote><p>A better approach is to use the blockhash of some future block. The implementation scenario is as follows:</p><p>毅哥更好的方法是使用一些未来的区块，实现方案如下：</p><ul><li><p>The player makes a bet and the house stores the block.number of the transaction.</p><p>玩家下注，房屋将存储交易的block.number。</p></li><li><p>In a second call to the contract, the player requests that the house announces the winning number.</p><p>在第二次致电合约时，玩家要求房主宣布中奖号码。</p></li><li><p>The house retrieves the saved block.number from storage and gets its blockhash, which is then used to generate a pseudo-random number.</p><p>房子从存储中检索保存的block.number并获取其blockhash，然后将其用于生成伪随机数。</p></li></ul><p>This approach works only if an important requirement is met. The Solidity documentation warns about the limit of saved blockhashes that the EVM is able to store: The block hashes are not available for all blocks for scalability reasons. You can only access the hashes of the most recent 256 blocks, all other values will be zero.</p><p>仅当满足重要要求时，此方法才有效。Solidity文档警告了EVM可以存储的已保存块哈希的限制：block hashes出于可扩展的考虑，并不对所有区块有效，你仅能获取最新的256个区块的hash值，其他区块hash值返回为0。</p></blockquote><h3 id="基于过去区块的区块哈希结合被视为私有的种子的PRNG"><a href="#基于过去区块的区块哈希结合被视为私有的种子的PRNG" class="headerlink" title="基于过去区块的区块哈希结合被视为私有的种子的PRNG"></a>基于过去区块的区块哈希结合被视为私有的种子的PRNG</h3><p>这个玩法不行，因为区块链没有真正意义上的私有变量，实际都可查。。。</p><h3 id="PRNG易于抢先"><a href="#PRNG易于抢先" class="headerlink" title="PRNG易于抢先"></a>PRNG易于抢先</h3><p>这个应该也可以算作前置交易漏洞，以太坊的打包政策是，给的gas price高的优先，这就很有操作空间了</p><h4 id="实际例子-2"><a href="#实际例子-2" class="headerlink" title="实际例子"></a>实际例子</h4><blockquote><p>Consider the following example. A lottery uses an external oracle to get pseudo-random numbers, which are used to determine the winner from among the players who submitted their bets in each round. These numbers are sent unencrypted. An attacker may observe the pool of pending transactions and wait for the number from the oracle. As soon as the oracle’s transaction appears in the transaction pool, an attacker sends a bet with a higher gas price. The attacker’s transaction was made last in the round, but thanks to the higher gas price, is actually executed before the oracle’s transaction, making the attacker victorious. Such a task was featured in the <a href="https://blog.positive.com/zeronights-ico-hacking-contest-writeup-63afb996f1e3" target="_blank" rel="noopener">ZeroNights ICO Hacking Contest</a>.</p></blockquote><p>考虑以下示例。彩票使用外部预言机来获取伪随机数，该伪随机数用于在每个回合中提交赌注的玩家中确定赢家。这些数字未加密发送。攻击者可能会观察等待交易事务池，并等待来自oracle的数字。一旦oracle的交易出现在交易池中，攻击者便以更高的汽油价格发送赌注。由于汽油价格上涨，攻击者的交易虽然提交的晚，但是确可以在oracle的交易之前执行的，这使攻击者取得了胜利。在<a href="https://blog.positive.com/zeronights-ico-hacking-contest-writeup-63afb996f1e3" target="_blank" rel="noopener">ZeroNights ICO黑客大赛</a>中就有这样一个赌注。</p><blockquote><p>Another example of a contract prone to front-running is the game called “<a href="https://etherscan.io/address/0x5d9b8fa00c16bcafae47deed872e919c8f6535bf" target="_blank" rel="noopener">Last is me!</a>”. Every time a player buys a ticket, that player claims the last seat and the timer starts counting down. If nobody buys the ticket within a certain number of blocks, the last player to “take a seat” wins the jackpot. When the round is about to finish, an attacker may observe the transaction pool for other contestants’ transactions and claim the jackpot by means of a higher gas price.</p></blockquote><p>容易发生抢占先机的另一个例子是名为“<a href="https://etherscan.io/address/0x5d9b8fa00c16bcafae47deed872e919c8f6535bf" target="_blank" rel="noopener">Last is me！Last</a> ”的游戏。玩家每次购买彩票时，该玩家将获得最后一个席位，计时器开始倒计时。如果没有人在一定数量的区块内购买彩票，则最后一个“坐下来”的玩家将赢得大奖。当该回合即将结束时，攻击者可能会观察其他参赛者的交易的交易池，并通过更高的汽油价格索取大奖。</p><h3 id="更好的随机数生成办法"><a href="#更好的随机数生成办法" class="headerlink" title="更好的随机数生成办法"></a>更好的随机数生成办法</h3><p>文章共提到了三种：Oracle or BTCReply\Signidice\Commit–reveal</p><h4 id="Oracle"><a href="#Oracle" class="headerlink" title="Oracle"></a>Oracle</h4><p>就是外部预言机，老铁用图解释的很清楚</p><p><img src="https://i.loli.net/2020/04/20/vKRM7dZBpP2lDuO.png" alt="外部预言机流程"></p><p>其中红色的就是链上的内容，Oraclize daemon和random.org则是链下内容，而且不可控，所以说除非你完全信任两者，不然这也是有风险的。</p><h4 id="BTCReply"><a href="#BTCReply" class="headerlink" title="BTCReply"></a>BTCReply</h4><p>其实BTCReply就是把以太坊的矿工风险转移到了比特币矿工风险。<a href="http://btcrelay.org/" target="_blank" rel="noopener">BTCRelay</a>是以太坊和比特币区块链之间的桥梁。使用BTCRelay，以太坊区块链中的智能合约可以请求将来的比特币区块哈希并将其用作熵的来源。将BTCRelay用作PRNG的一个项目是<a href="https://etherscan.io/address/0x302fE87B56330BE266599FAB2A54747299B5aC5B" target="_blank" rel="noopener">以太坊彩票</a>。</p><p>感觉只是提高了作弊代价阈值吧</p><h4 id="Signidice"><a href="#Signidice" class="headerlink" title="Signidice"></a>Signidice</h4><p>感觉<a href="https://github.com/gluk256/misc/blob/master/rng4ethereum/signidice.md" target="_blank" rel="noopener">Signidice</a>就是利用算法签名来锁定下注者，也就是一旦出现下注者，就利用赌注所有者的私钥加签名锁定这个下注，然后合约用公钥解签来验证。摘录一下完整流程</p><blockquote><p>该算法适用于那些基于以太坊的游戏，其中玩家的每一轮结果仅取决于RNG和（可选）玩家选择的数字，而不取决于其他玩家的动作。例如，它可能适用于轮盘赌，角子机等，但不适用于那些结果取决于其他玩家或仅取决于其人数的游戏（例如彩票业）。例如，轮盘游戏可以建模为多个回合，其中单个玩家与赌场对战。在这种情况下，可以使用以下算法生成伪随机数。</p><p>​ 1. 赌场为确定性签名算法（例如RSA）生成一对新的私钥/公钥（PrivKey和PubKey）。</p><p>​ 2. 赌场创建一个智能合约，其中包含公钥（PubKey），最大参与者数和以太坊赏金。（可选：赌场更改现有智能合约的PubKey）。</p><p>​ 3. 玩家选择要下注的数字（B）和某种格式（例如20字节）的随机数（R）。如果游戏规则允许，则玩家甚至可以指定数字B的范围（奇数与偶数等）。</p><p>​ 4. 玩家发送包含以太币投注以及数据B和R的交易（TX）。</p><p>​ 5. 合同检查数字B和R的有效性和格式。无效的TX被拒绝。</p><p>​ 6. 此外，合同还会检查该球员在之前的回合中是否已经使用过数字R，在这种情况下，TX被拒绝。（如果合同被重复用于多轮游戏，则此步骤是必需的）。</p><p>​ 7. 合同将随机数R与玩家的以太帐户的公共地址（A）串联在一起，从该地址发送TX：V = A +R。结果值V存储在合同中。V的大小始终相同：size（V）= size（A）+ size（R）。在这一点上，回合的结果（胜利或失败）成为确定性的。</p><p>​ 8. 娱乐场必须使用其PrivKey对结果值V进行签名，从而产生数字签名S = sign（PrivKey，V），并发送包含S的相应TX。</p><p>​ 9. 合同从数字签名S中恢复实际的公钥（K），并验证它是否等于先前发布的PubKey（K == PubKey）。如果APK与PubKey不匹配，或者娱乐场未能在预定义的时间范围内执行步骤8，则等同于作弊。在这种情况下，合同会将奖金和原始赌注一起发送给玩家，然后通过自杀关闭合同。（在多人游戏的情况下，所有玩家共享赏金）。</p><p>​ 10. 合同使用S作为预定义PRNG算法（例如，基于SHA-3）的种子，该算法会生成幸运数字（L），例如介于0到36之间。</p><p>​ 11. 如果B对应于L，则玩家获胜，否则赌场获胜。合同将赌注发送给获胜者。</p><p>​ 12. 现在，赌场可能会关闭合同并收回赏金，或启动新一轮游戏。或者，可以将合同编程为自动进行下一轮，除非赌场将其关闭。</p><p>赌场选择了PrivKey之后，其操作将变为确定性的。玩家无法预测数字签名的结果，因此，他对随机数R的选择只能以与在现实生活中掷骰子相同的方式影响结果（因此该算法的名称）。因此，没有一个参与者可以任何有意义的方式操纵结果。</p></blockquote><p>需要注意的是，ECDSA算法不适合该算法，因为</p><blockquote><p>A [proof-of-concept](<a href="https://github.com/pertsev/web3_utilz/tree/master/ECDSA" target="_blank" rel="noopener">https://github.com/pertsev/web3_utilz/tree/master/ECDSA</a> signature generating (cheating)) of such cheating has been created by Alexey Pertsev.</p><p>Fortunately, with release of the Metropolis hardfork, a <a href="https://github.com/ethereum/EIPs/pull/198" target="_blank" rel="noopener">modular exponentiation operator</a> has been introduced. This allows implementing RSA signature verification, which unlike ECDSA does not allow manipulating input parameters to find a suitable signature.</p></blockquote><h4 id="commit-reveal"><a href="#commit-reveal" class="headerlink" title="commit-reveal"></a>commit-reveal</h4><p>所谓的提交-披露方法就是：</p><ul><li>“提交”阶段，当事双方将其受密码保护的机密提交给智能合约。</li><li>在“公开”阶段，当当事方宣布明文种子时，智能合约会验证它们是否正确，然后使用种子生成一个随机数。</li></ul><p>举个例子，所有者提供一个随机数seed1，玩家提供一个随机数seed2，但是在『提交』阶段，仅透露sha3(seed1)和sha3(seed2)的值，到公开阶段，双方再披露seed1和seed2的值，然后验证两者，最后生成一个随机数sha3(seed1, seed3, blockhash)，其中blockhash是未来区块hash值。</p><p>这个方法有个弊端就是，所有者也可以是玩家哦~所以，玩家无法信任所有者</p><p>文章有提到说<a href="https://github.com/randao/randao" target="_blank" rel="noopener">Randao</a>。该PRNG从多个方收集哈希种子，并向每个参与方奖励。没有人知道其他人的种子，因此结果确实是随机的。但是，单方拒绝透露种子将导致拒绝服务。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>所以这么看来，世上难得两全法啊~每个方法都有优势和弊端</p><p>区块链的熵源有限。设计PRNG时，开发人员应确保首先了解各方的动机，然后再选择适当的方法。</p><div class="article-copyright"><hr>本文作者: &nbsp;CapybaraJ<br>本文链接: &nbsp;<a herf="#">https://fatheadrat.tk/2020/04/03/smartcontract-vulns-2/</a><br>版权声明: &nbsp;除非注明，本博文章均为原创，转载请以链接形式标明本文地址<br></div></div><footer class="article-footer"><div class="article-footer-content"><h3 href="/2020/04/03/smartcontract-vulns-2/" class="article-updated">Updated&nbsp;:&nbsp;<time datetime="2020-04-20T03:02:09.904Z" itemprop="datePublished">2020-04-20</time></h3><ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SmartContract/">SmartContract</a></li></ul><a data-url="https://fatheadrat.tk/2020/04/03/smartcontract-vulns-2/" data-id="ck97w8rhs001yj3ajx5fwq1rw" class="article-share-link">Share</a> <a href="https://fatheadrat.tk/2020/04/03/smartcontract-vulns-2/#utterances" class="article-comment-link">Comments</a> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv" class="article-count-link"></span></span></div></footer></div></div></div><nav id="article-nav"><a href="/2020/04/02/smartcontract-vulns-1/" id="article-nav-older" class="article-nav-link-wrap"><strong class="article-nav-caption">Older</strong><div class="article-nav-title">智能合约漏洞介绍1</div></a></nav><div class="article-inner"><div class="fill-content"><section id="comments"><script src="https://utteranc.es/client.js" repo="CapybaraJ/capybaraj.github.io" issue-term="pathname" theme="github-light" crossorigin="anonymous" async></script></section></div></div></article></section><aside id="sidebar"><div class="widget-wrap"><h3 class="widget-title">Tag Cloud</h3><div class="widget tagcloud"><a href="/tags/SmartContract/" style="font-size:12.5px">SmartContract</a> <a href="/tags/ctf/" style="font-size:10px">ctf</a> <a href="/tags/docker/" style="font-size:10px">docker</a> <a href="/tags/ethereum/" style="font-size:17.5px">ethereum</a> <a href="/tags/geth/" style="font-size:12.5px">geth</a> <a href="/tags/git/" style="font-size:10px">git</a> <a href="/tags/github/" style="font-size:10px">github</a> <a href="/tags/go/" style="font-size:10px">go</a> <a href="/tags/hexo/" style="font-size:20px">hexo</a> <a href="/tags/iTerm/" style="font-size:10px">iTerm</a> <a href="/tags/markdown/" style="font-size:10px">markdown</a> <a href="/tags/php/" style="font-size:10px">php</a> <a href="/tags/py-evm/" style="font-size:15px">py-evm</a> <a href="/tags/remix/" style="font-size:10px">remix</a> <a href="/tags/sql/" style="font-size:12.5px">sql</a> <a href="/tags/zsh/" style="font-size:10px">zsh</a></div></div><div class="widget-wrap"><h3 class="widget-title">Categories</h3><div class="widget"><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/BlockChain/">BlockChain</a><span class="category-list-count">10</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Programming/">Programming</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/WEB/">WEB</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/分享/">分享</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/前端/">前端</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/工具指导/">工具指导</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/读书笔记/">读书笔记</a><span class="category-list-count">1</span></li></ul></div></div><div class="widget-wrap"><h3 class="widget-title">Archives</h3><div class="widget"><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">December 2019</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a><span class="archive-list-count">8</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">June 2019</a><span class="archive-list-count">10</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">July 2018</a><span class="archive-list-count">1</span></li></ul></div></div><div class="widget-wrap"><h3 class="widget-title">Links</h3><div class="link-lists widget"><ul><li><a href="https://www.sun11.me/blog/2016/hexo-theme-paperbox/" target="_blank">Paperbox</a></li><li><a href="https://paper.seebug.org/" target="_blank">Paper</a></li></ul></div></div></aside></div><footer id="footer"><div class="outer"><div id="footer-info" class="inner">&copy; 2018~2020 CapybaraJ&nbsp;<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span class="post-meta-divider">|</span> <span id="busuanzi_container_site_pv">Views&nbsp;<span id="busuanzi_value_site_pv"></span></span> <span class="post-meta-divider">|</span> <span id="busuanzi_container_site_uv">Visitors&nbsp;<span id="busuanzi_value_site_uv"></span></span><br>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a> . Theme by <a href="https://github.com/sun11/hexo-theme-paperbox" target="_blank">Paperbox</a></div></div></footer></div><nav id="mobile-nav"><a href="/" class="mobile-nav-link">Home</a> <a href="/archives" class="mobile-nav-link">Archives</a> <a href="/about" class="mobile-nav-link">About</a> <a href="#search" class="mobile-nav-link st-search-show-outputs">Search</a></nav><div id="totop"><a title="To Top"></a></div><script src="//cdnjs.cloudflare.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script><script src="//cdnjs.cloudflare.com/ajax/libs/lrsjng.jquery-qrcode/0.12.0/jquery.qrcode.min.js"></script><link rel="stylesheet" href="/fancybox/jquery.fancybox.css"><script src="/fancybox/jquery.fancybox.pack.js"></script><script src="/js/script.js"></script></div></body><!-- rebuild by neat -->